#ifndef GXM_DEBUG_HPP
#define GXM_DEBUG_HPP

#include "core/aes.hpp"
#include "core/debug.hpp"
#include "gxmCompatibilty.h"

#define AES_GXM_CHECK(err) if (err != SCE_OK) { AES_LOG_ERROR("AES_GXM_CHECK {}", sceGxmErrorToString(err)); AES_DEBUG_BREAK(); } 
// @Review replace with generic SCE_ERROR if possible
	inline const char* sceGxmErrorToString(unsigned int err)
	{
#define AES_ERR_CASE(x) case x: return #x;
		switch (err)
		{
			AES_ERR_CASE(SCE_OK)
			AES_ERR_CASE(SCE_GXM_ERROR_INVALID_POINTER)
			AES_ERR_CASE(SCE_GXM_ERROR_NOT_WITHIN_SCENE)
			// AES_ERR_CASE(SCE_GXM_ERROR_NOT_WITHIN_COMMAND_LIST)
			AES_ERR_CASE(SCE_GXM_ERROR_NULL_PROGRAM)
			AES_ERR_CASE(SCE_GXM_ERROR_UNIFORM_BUFFER_NOT_RESERVED)
			// AES_ERR_CASE(SCE_GXM_ERROR_INVALID_DEPTH_STENCIL_CONFIGURATION)
			AES_ERR_CASE(SCE_GXM_ERROR_RESERVE_FAILED)
			AES_ERR_CASE(SCE_GXM_ERROR_INVALID_INDEX_COUNT)
			AES_ERR_CASE(SCE_GXM_ERROR_INVALID_POLYGON_MODE)
			// AES_ERR_CASE(SCE_GXM_ERROR_INVALID_PRIMITIVE_TYPE)
			AES_ERR_CASE(SCE_GXM_ERROR_INVALID_SAMPLER_RESULT_TYPE_PRECISION)
			AES_ERR_CASE(SCE_GXM_ERROR_INVALID_SAMPLER_RESULT_TYPE_COMPONENT_COUNT)
			AES_ERR_CASE(SCE_GXM_ERROR_ALREADY_INITIALIZED)
			AES_ERR_CASE(SCE_GXM_ERROR_INVALID_VALUE)
			AES_ERR_CASE(SCE_GXM_ERROR_OUT_OF_MEMORY)
			AES_ERR_CASE(SCE_GXM_ERROR_DRIVER)
			// AES_ERR_CASE(SCE_GXM_ERROR_BUFFER_OVERRUN)
			default:
				return "unknown";
		}
#undef AES_ERR_CASE
	}


#endif